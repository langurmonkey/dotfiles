#!/usr/bin/env python3
import sys
import os
import re

# Note the 'r' prefix here to prevent Python from interpreting the backslash
UNICODE_ESCAPE_RE = re.compile(r'\\u[0-9a-fA-F]{4}')

def decode_match(match):
    # This converts the string '\u30AB' into the actual character
    return match.group(0).encode('ascii').decode('unicode_escape')

def process_file(file_path):
    r"""Unescapes \uXXXX sequences and saves as UTF-8 WITHOUT BOM."""
    if not file_path.endswith('.properties'):
        return

    try:
        # Read as UTF-8. Using 'utf-8-sig' here as a safety measure 
        # so it automatically strips an existing BOM if it finds one.
        with open(file_path, 'r', encoding='utf-8-sig', errors='ignore') as f:
            content = f.read()

        # Replace the \uXXXX sequences with their actual characters
        decoded_content = UNICODE_ESCAPE_RE.sub(decode_match, content)

        # Write with standard UTF-8 (NO BOM)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(decoded_content)

        print(f"[+] Converted (No BOM): '{file_path}'")
        
    except Exception as e:
        print(f"[!] Error processing '{file_path}': {e}")

def main():
    if len(sys.argv) < 2:
        print("Usage: toutf8 <file_or_directory>")
        sys.exit(1)

    path = sys.argv[1]

    if os.path.isfile(path):
        process_file(path)
    elif os.path.isdir(path):
        print(f"Scanning directory: {path}...")
        for root, _, files in os.walk(path):
            for file in files:
                if file.endswith('.properties'):
                    process_file(os.path.join(root, file))
    else:
        print(f"Error: '{path}' is not a valid file or directory.")
        sys.exit(1)

if __name__ == "__main__":
    main()
